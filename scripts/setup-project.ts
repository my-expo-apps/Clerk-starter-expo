/* eslint-disable no-console */
import { spawnSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';

type Step = { name: string; ok: boolean; detail?: string };

function env(name: string): string | null {
  const v = process.env[name];
  return v && v.trim().length ? v.trim() : null;
}

function requireEnv(name: string): string {
  const v = env(name);
  if (!v) throw new Error(`Missing env: ${name}`);
  return v;
}

function run(cmd: string, args: string[], opts?: { cwd?: string; redactArgs?: boolean }) {
  const res = spawnSync(cmd, args, {
    cwd: opts?.cwd ?? process.cwd(),
    stdio: 'pipe',
    shell: false,
    encoding: 'utf8',
  });

  if (res.error) throw res.error;
  if (res.status !== 0) {
    const out = (res.stdout ?? '') + (res.stderr ?? '');
    throw new Error(`${cmd} failed (exit ${res.status}). ${out}`.trim());
  }
  return (res.stdout ?? '').trim();
}

function hasCli(cmd: string, versionArgs = ['--version']) {
  try {
    const out = run(cmd, versionArgs);
    return { ok: true as const, version: out };
  } catch {
    return { ok: false as const, version: '' };
  }
}

function writeEnvFile(targetPath: string, content: string) {
  fs.writeFileSync(targetPath, content, { encoding: 'utf8' });
}

function safeEnvLine(key: string, value: string) {
  // Avoid newlines; keep it simple.
  const v = value.replace(/\r?\n/g, '');
  return `${key}=${v}`;
}

async function main() {
  const steps: Step[] = [];
  const push = (s: Step) => steps.push(s);

  // Load .env.template? We intentionally only use process.env so users can run this in CI.

  const supabase = hasCli('supabase', ['--version']);
  push({ name: 'Supabase CLI installed', ok: supabase.ok, detail: supabase.ok ? supabase.version : 'Install: https://supabase.com/docs/guides/cli' });
  if (!supabase.ok) return finish(steps, 1);

  const clerk = hasCli('clerk', ['--version']);
  push({
    name: 'Clerk CLI installed',
    ok: clerk.ok,
    detail: clerk.ok ? clerk.version : 'Install: https://clerk.com/docs (CLI)',
  });
  // Clerk CLI is optional for now; we validate issuer/audience via env.

  const projectRef = requireEnv('SUPABASE_PROJECT_REF');
  const dbPassword = requireEnv('SUPABASE_DB_PASSWORD');

  const clerkIssuer = requireEnv('CLERK_JWT_ISSUER');
  const clerkAudience = requireEnv('CLERK_EXPECTED_AUDIENCE');

  // Basic validation (no secrets printed)
  try {
    // eslint-disable-next-line no-new
    new URL(clerkIssuer);
    push({ name: 'Clerk JWT issuer valid URL', ok: true });
  } catch {
    push({ name: 'Clerk JWT issuer valid URL', ok: false, detail: 'CLERK_JWT_ISSUER is not a valid URL' });
    return finish(steps, 1);
  }

  push({ name: 'Clerk expected audience present', ok: !!clerkAudience });

  // Link (non-interactive)
  try {
    run('supabase', ['link', '--project-ref', projectRef, '--password', dbPassword]);
    push({ name: 'supabase link', ok: true });
  } catch (e) {
    push({ name: 'supabase link', ok: false, detail: (e as Error).message });
    return finish(steps, 1);
  }

  // Push migrations
  try {
    run('supabase', ['db', 'push']);
    push({ name: 'supabase db push', ok: true });
  } catch (e) {
    push({ name: 'supabase db push', ok: false, detail: (e as Error).message });
    return finish(steps, 1);
  }

  // Deploy edge functions (no-verify-jwt because we validate ourselves)
  const functions = ['clerk-jwt-verify', 'bootstrap-system', 'bootstrap-status'];
  for (const fn of functions) {
    try {
      run('supabase', ['functions', 'deploy', fn, '--no-verify-jwt']);
      push({ name: `deploy function: ${fn}`, ok: true });
    } catch (e) {
      push({ name: `deploy function: ${fn}`, ok: false, detail: (e as Error).message });
      return finish(steps, 1);
    }
  }

  // Generate .env (for local dev only; do not commit)
  const repoRoot = process.cwd();
  const envPath = path.join(repoRoot, '.env');
  const already = fs.existsSync(envPath);
  const outPath = already ? path.join(repoRoot, '.env.generated') : envPath;

  const publishableKey = env('EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY') ?? 'pk_test_...';
  const supabaseUrl = env('SUPABASE_URL') ?? 'https://YOUR-PROJECT-REF.supabase.co';
  const supabaseAnonKey = env('SUPABASE_ANON_KEY') ?? 'YOUR_SUPABASE_ANON_KEY';

  const content = [
    '# Generated by scripts/setup-project.ts',
    '# Do not commit this file.',
    '',
    safeEnvLine('EXPO_PUBLIC_CLERK_PUBLISHABLE_KEY', publishableKey),
    '',
    safeEnvLine('SUPABASE_URL', supabaseUrl),
    safeEnvLine('SUPABASE_ANON_KEY', supabaseAnonKey),
    '',
    safeEnvLine('CLERK_JWT_ISSUER', clerkIssuer),
    safeEnvLine('CLERK_EXPECTED_AUDIENCE', clerkAudience),
    '',
  ].join('\n');

  try {
    writeEnvFile(outPath, content);
    push({ name: `generate ${path.basename(outPath)}`, ok: true, detail: already ? 'Existing .env detected; wrote .env.generated instead.' : undefined });
  } catch (e) {
    push({ name: 'generate .env', ok: false, detail: (e as Error).message });
    return finish(steps, 1);
  }

  return finish(steps, 0);
}

function finish(steps: Step[], exitCode: number) {
  for (const s of steps) {
    const icon = s.ok ? '✔' : '✖';
    const suffix = s.detail ? ` — ${s.detail}` : '';
    console.log(`${icon} ${s.name}${suffix}`);
  }
  process.exit(exitCode);
}

main().catch((e) => {
  console.error('✖ setup-project: unexpected error');
  console.error((e as Error).message);
  process.exit(1);
});

